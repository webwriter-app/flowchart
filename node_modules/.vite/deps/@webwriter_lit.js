import {
  LitElement,
  adoptStyles
} from "./chunk-WWTN2XES.js";
import {
  property
} from "./chunk-KWVJEYRK.js";
import {
  __decorateClass
} from "./chunk-CBEIUQ5X.js";

// node_modules/@open-wc/dedupe-mixin/src/dedupeMixin.js
var appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}

// node_modules/@open-wc/scoped-elements/src/ScopedElementsMixin.js
var supportsScopedRegistry = !!ShadowRoot.prototype.createElement;
var ScopedElementsMixinImplementation = (superclass) => class ScopedElementsHost extends superclass {
  static get scopedElements() {
    return {};
  }
  static get shadowRootOptions() {
    return this.__shadowRootOptions;
  }
  static set shadowRootOptions(value) {
    this.__shadowRootOptions = value;
  }
  static get elementStyles() {
    return this.__elementStyles;
  }
  static set elementStyles(styles) {
    this.__elementStyles = styles;
  }
  constructor(..._args) {
    super();
    this.renderOptions = this.renderOptions || void 0;
  }
  get registry() {
    return this.constructor.__registry;
  }
  set registry(registry) {
    this.constructor.__registry = registry;
  }
  createRenderRoot() {
    const { scopedElements, shadowRootOptions, elementStyles } = this.constructor;
    const shouldCreateRegistry = !this.registry || this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
    if (shouldCreateRegistry) {
      this.registry = supportsScopedRegistry ? new CustomElementRegistry() : customElements;
      for (const [tagName, klass] of Object.entries(scopedElements)) {
        this.defineScopedElement(tagName, klass);
      }
    }
    const options = {
      mode: "open",
      ...shadowRootOptions,
      customElements: this.registry
    };
    const createdRoot = this.attachShadow(options);
    if (supportsScopedRegistry) {
      this.renderOptions.creationScope = createdRoot;
    }
    if (createdRoot instanceof ShadowRoot) {
      adoptStyles(createdRoot, elementStyles);
      this.renderOptions.renderBefore = this.renderOptions.renderBefore || createdRoot.firstChild;
    }
    return createdRoot;
  }
  createScopedElement(tagName) {
    const root = supportsScopedRegistry ? this.shadowRoot : document;
    return root.createElement(tagName);
  }
  defineScopedElement(tagName, klass) {
    const registeredClass = this.registry.get(tagName);
    if (registeredClass && supportsScopedRegistry === false && registeredClass !== klass) {
      console.error(
        [
          `You are trying to re-register the "${tagName}" custom element with a different class via ScopedElementsMixin.`,
          "This is only possible with a CustomElementRegistry.",
          "Your browser does not support this feature so you will need to load a polyfill for it.",
          'Load "@webcomponents/scoped-custom-element-registry" before you register ANY web component to the global customElements registry.',
          'e.g. add "<script src="/node_modules/@webcomponents/scoped-custom-element-registry/scoped-custom-element-registry.min.js"><\/script>" as your first script tag.',
          "For more details you can visit https://open-wc.org/docs/development/scoped-elements/"
        ].join("\n")
      );
    }
    if (!registeredClass) {
      return this.registry.define(tagName, klass);
    }
    return this.registry.get(tagName);
  }
  getScopedTagName(tagName) {
    return tagName;
  }
  static getScopedTagName(tagName) {
    return tagName;
  }
};
var ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);

// node_modules/@webwriter/lit/index.ts
var LitElementWw = class extends ScopedElementsMixin(LitElement) {
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((n) => this.setAttribute(n, this.getAttribute(n)));
  }
};
LitElementWw.shadowRootOptions = { ...ScopedElementsMixin(LitElement).shadowRootOptions, delegatesFocus: true };
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], LitElementWw.prototype, "printable", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], LitElementWw.prototype, "editable", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], LitElementWw.prototype, "analyzable", 2);
export {
  LitElementWw
};
//# sourceMappingURL=@webwriter_lit.js.map

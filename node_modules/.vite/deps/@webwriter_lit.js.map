{
  "version": 3,
  "sources": ["../../@open-wc/dedupe-mixin/src/dedupeMixin.js", "../../@open-wc/scoped-elements/src/ScopedElementsMixin.js", "../../@webwriter/lit/index.ts"],
  "sourcesContent": ["const appliedClassMixins = new WeakMap();\r\n\r\n/** Vefify if the Mixin was previously applyed\r\n * @private\r\n * @param {function} mixin      Mixin being applyed\r\n * @param {object} superClass   Class receiving the new mixin\r\n * @returns {boolean}\r\n */\r\nfunction wasMixinPreviouslyApplied(mixin, superClass) {\r\n  let klass = superClass;\r\n  while (klass) {\r\n    if (appliedClassMixins.get(klass) === mixin) {\r\n      return true;\r\n    }\r\n    klass = Object.getPrototypeOf(klass);\r\n  }\r\n  return false;\r\n}\r\n\r\n/** Apply each mixin in the chain to make sure they are not applied more than once to the final class.\r\n * @export\r\n * @param {function} mixin      Mixin to be applyed\r\n * @returns {object}            Mixed class with mixin applied\r\n */\r\nexport function dedupeMixin(mixin) {\r\n  return superClass => {\r\n    if (wasMixinPreviouslyApplied(mixin, superClass)) {\r\n      return superClass;\r\n    }\r\n    const mixedClass = mixin(superClass);\r\n    appliedClassMixins.set(mixedClass, mixin);\r\n    return mixedClass;\r\n  };\r\n}\r\n", "import { dedupeMixin } from '@open-wc/dedupe-mixin';\r\nimport { adoptStyles } from '@lit/reactive-element/css-tag.js';\r\n\r\n/**\r\n * @typedef {import('./types').RenderOptions} RenderOptions\r\n * @typedef {import('./types').ScopedElementsMixin} ScopedElementsMixin\r\n * @typedef {import('./types').ScopedElementsHost} ScopedElementsHost\r\n * @typedef {import('./types').ScopedElementsMap} ScopedElementsMap\r\n * @typedef {import('@lit/reactive-element').CSSResultOrNative} CSSResultOrNative\r\n */\r\n\r\n// @ts-ignore\r\nconst supportsScopedRegistry = !!ShadowRoot.prototype.createElement;\r\n\r\n/**\r\n * @template {import('./types').Constructor<HTMLElement>} T\r\n * @param {T} superclass\r\n * @return {T & import('./types').Constructor<ScopedElementsHost>}\r\n */\r\nconst ScopedElementsMixinImplementation = superclass =>\r\n  /** @type {ScopedElementsHost} */\r\n  class ScopedElementsHost extends superclass {\r\n    /**\r\n     * Obtains the scoped elements definitions map if specified.\r\n     *\r\n     * @returns {ScopedElementsMap}\r\n     */\r\n    static get scopedElements() {\r\n      return {};\r\n    }\r\n\r\n    /**\r\n     * Obtains the ShadowRoot options.\r\n     *\r\n     * @type {ShadowRootInit}\r\n     */\r\n    static get shadowRootOptions() {\r\n      return this.__shadowRootOptions;\r\n    }\r\n\r\n    /**\r\n     * Set the shadowRoot options.\r\n     *\r\n     * @param {ShadowRootInit} value\r\n     */\r\n    static set shadowRootOptions(value) {\r\n      this.__shadowRootOptions = value;\r\n    }\r\n\r\n    /**\r\n     * Obtains the element styles.\r\n     *\r\n     * @returns {CSSResultOrNative[]}\r\n     */\r\n    static get elementStyles() {\r\n      return this.__elementStyles;\r\n    }\r\n\r\n    static set elementStyles(styles) {\r\n      this.__elementStyles = styles;\r\n    }\r\n\r\n    // either TS or ESLint will complain here\r\n    // eslint-disable-next-line no-unused-vars\r\n    constructor(..._args) {\r\n      super();\r\n      /** @type {RenderOptions} */\r\n      this.renderOptions = this.renderOptions || undefined;\r\n    }\r\n\r\n    /**\r\n     * Obtains the CustomElementRegistry associated to the ShadowRoot.\r\n     *\r\n     * @returns {CustomElementRegistry}\r\n     */\r\n    get registry() {\r\n      // @ts-ignore\r\n      return this.constructor.__registry;\r\n    }\r\n\r\n    /**\r\n     * Set the CustomElementRegistry associated to the ShadowRoot\r\n     *\r\n     * @param {CustomElementRegistry} registry\r\n     */\r\n    set registry(registry) {\r\n      // @ts-ignore\r\n      this.constructor.__registry = registry;\r\n    }\r\n\r\n    createRenderRoot() {\r\n      const { scopedElements, shadowRootOptions, elementStyles } =\r\n        /** @type {typeof ScopedElementsHost} */ (this.constructor);\r\n\r\n      const shouldCreateRegistry =\r\n        !this.registry ||\r\n        // @ts-ignore\r\n        (this.registry === this.constructor.__registry &&\r\n          !Object.prototype.hasOwnProperty.call(this.constructor, '__registry'));\r\n\r\n      /**\r\n       * Create a new registry if:\r\n       * - the registry is not defined\r\n       * - this class doesn't have its own registry *AND* has no shared registry\r\n       */\r\n      if (shouldCreateRegistry) {\r\n        this.registry = supportsScopedRegistry ? new CustomElementRegistry() : customElements;\r\n        for (const [tagName, klass] of Object.entries(scopedElements)) {\r\n          this.defineScopedElement(tagName, klass);\r\n        }\r\n      }\r\n\r\n      /** @type {ShadowRootInit} */\r\n      const options = {\r\n        mode: 'open',\r\n        ...shadowRootOptions,\r\n        customElements: this.registry,\r\n      };\r\n\r\n      const createdRoot = this.attachShadow(options);\r\n      if (supportsScopedRegistry) {\r\n        this.renderOptions.creationScope = createdRoot;\r\n      }\r\n\r\n      if (createdRoot instanceof ShadowRoot) {\r\n        adoptStyles(createdRoot, elementStyles);\r\n        this.renderOptions.renderBefore = this.renderOptions.renderBefore || createdRoot.firstChild;\r\n      }\r\n\r\n      return createdRoot;\r\n    }\r\n\r\n    createScopedElement(tagName) {\r\n      const root = supportsScopedRegistry ? this.shadowRoot : document;\r\n      // @ts-ignore polyfill to support createElement on shadowRoot is loaded\r\n      return root.createElement(tagName);\r\n    }\r\n\r\n    /**\r\n     * Defines a scoped element.\r\n     *\r\n     * @param {string} tagName\r\n     * @param {typeof HTMLElement} klass\r\n     */\r\n    defineScopedElement(tagName, klass) {\r\n      const registeredClass = this.registry.get(tagName);\r\n      if (registeredClass && supportsScopedRegistry === false && registeredClass !== klass) {\r\n        // eslint-disable-next-line no-console\r\n        console.error(\r\n          [\r\n            `You are trying to re-register the \"${tagName}\" custom element with a different class via ScopedElementsMixin.`,\r\n            'This is only possible with a CustomElementRegistry.',\r\n            'Your browser does not support this feature so you will need to load a polyfill for it.',\r\n            'Load \"@webcomponents/scoped-custom-element-registry\" before you register ANY web component to the global customElements registry.',\r\n            'e.g. add \"<script src=\"/node_modules/@webcomponents/scoped-custom-element-registry/scoped-custom-element-registry.min.js\"></script>\" as your first script tag.',\r\n            'For more details you can visit https://open-wc.org/docs/development/scoped-elements/',\r\n          ].join('\\n'),\r\n        );\r\n      }\r\n      if (!registeredClass) {\r\n        return this.registry.define(tagName, klass);\r\n      }\r\n      return this.registry.get(tagName);\r\n    }\r\n\r\n    /**\r\n     * @deprecated use the native el.tagName instead\r\n     *\r\n     * @param {string} tagName\r\n     * @returns {string} the tag name\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    getScopedTagName(tagName) {\r\n      return tagName;\r\n    }\r\n\r\n    /**\r\n     * @deprecated use the native el.tagName instead\r\n     *\r\n     * @param {string} tagName\r\n     * @returns {string} the tag name\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    static getScopedTagName(tagName) {\r\n      return tagName;\r\n    }\r\n  };\r\n\r\nexport const ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);\r\n", "import {LitElement} from \"lit\"\r\nimport { property } from \"lit/decorators.js\"\r\nimport {ScopedElementsMixin} from \"@open-wc/scoped-elements\"\r\n\r\nimport {Widget} from \"@webwriter/model\"\r\n\r\n/**WebWriter API: Minimal base class for a widget implemented in Lit. Implements the core properties required by WebWriter, initializes the component when loaded and provides a Scoped Custom Element Registry (@open-wc/scoped-elements) to help with namespace conflicts when using other components in this widget. */\r\nexport class LitElementWw extends ScopedElementsMixin(LitElement) implements Widget {\r\n\r\n  static shadowRootOptions = {...ScopedElementsMixin(LitElement).shadowRootOptions, delegatesFocus: true}\r\n  \r\n  /**WebWriter API: If true, render the component such that easy printing is possible. */\r\n  @property({type: Boolean, attribute: true, reflect: true})\r\n  printable: boolean\r\n\r\n  /**WebWriter API: If true, allow user interaction to change the component. */\r\n  @property({type: Boolean, attribute: true, reflect: true})\r\n  editable: boolean\r\n\r\n  /**WebWriter API: If true, emit DOM events enriched with xAPI statements. */\r\n  @property({type: Boolean, attribute: true, reflect: true})\r\n  analyzable: boolean\r\n\r\n  connectedCallback() {\r\n    super.connectedCallback()\r\n    this.getAttributeNames().forEach(n => this.setAttribute(n, this.getAttribute(n)))\r\n  }\r\n}"],
  "mappings": "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",
  "names": []
}
